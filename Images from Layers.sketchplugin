// Sketch Framer (ctrl alt command d)

/* Import the variables and complain if they are undefined */
#import 'sandbox.js'


/* Configuration */
var framerjs_url = "http://rawgit.com/koenbok/Framer/master/build/framer.js";

function major_version() {
  return [NSApp applicationVersion].substr(0,1);
}

function should_become_view(layer) {
  return is_group(layer) || [layer name].slice(-1) == '+';
}
function is_group(layer) {
  return [layer isMemberOfClass:[MSLayerGroup class]] || [layer isMemberOfClass:[MSArtboardGroup class]]
}
function should_ignore_layer(layer) {
  return [layer name].slice(-1) == '-' || [layer className] == "MSPage";
}
function sanitize_filename(name){
  return name.replace(/(\s|:|\/)/g ,"_").replace(/__/g,"_").replace("*","").replace("+","").replace("@@hidden","");
}
function has_art(layer) {
  // return true;

  if(is_group(layer) && !should_flatten_layer(layer)) {
    var has_art = false;

    var sublayers = [layer layers];
    for (var sub=([sublayers count] - 1); sub >= 0; sub--) {
      var sublayer = [sublayers objectAtIndex:sub]
      if(!should_ignore_layer(sublayer) && !should_become_view(sublayer)) {
        has_art = true;
      }
    }
    return has_art;

  } else {
    return true;
  }
}
function export_layer(layer, depth) {
  log_depth("Exporting <" + [layer name] + ">", depth);
  var filename = images_folder + "/" + sanitize_filename([layer name]) + ".png";

  if([layer isMemberOfClass:[MSArtboardGroup class]] && major_version == 3) {
    [[NSApplication sharedApplication] displayDialog:"Sketch Framer currently doesn't support artboards with Sketch 3. Please remove the artboard and have layers directly on the canvas. You can group everything at the top level and move it to (0,0) for intended results." withTitle:"Sketch Framer known bugs"]
  }

  if(has_art) {
    
    // export
    //TODO: Instead of using sketch styles, make them CSS and just use [[layer absoluteRect] rect]
    var rect = [layer rectByAccountingForStyleSize:[[layer absoluteRect] rect]],
        slice = [MSSlice sliceWithRect:rect scale:1];

    if (in_sandbox()) {
      sandboxAccess.accessFilePath_withBlock_persistPermission(target_folder, function(){
        [doc saveArtboardOrSlice:slice toFile:filename];
      }, true)
    } else {
      [doc saveArtboardOrSlice:slice toFile:filename];
    }
  }

  // remove it
  //[layer removeFromParent];
}
function should_flatten_layer(layer) {
  var name = [layer name];
  if(name.slice(-1) == "*") {
    return true;
  } else {
    return false;
  }
}
function log_depth(message, depth) {
  var padding = "";
  for(var i=0; i<depth; i++) {
    padding = padding + ">"
  }
  log(padding + " " + message);
}
function process_layer(layer,metadata_container,depth) {

  if (should_ignore_layer(layer)) {
    log_depth("Ignoring <" + [layer name] + "> of type <" + [layer className] + ">", depth);
    return;
  }

  if(should_become_view(layer)){
    log_depth("Processing <" + [layer name] + "> of type <" + [layer className] + ">", depth);
    // If layer is a group, do:

    // temporarily show it
    if (![layer isVisible]) {
      [layer setName:[layer name] + "@@hidden"]
    }
    [layer setIsVisible:true];

    // - Get layer data
    var layer_data = extract_metadata_from(layer);
    layer_data.children = [];

    // - Export image if layer has no subgroups
    if (!should_flatten_layer(layer) && is_group(layer)) {
      var sublayers = [layer layers];
      // Apparently, Sketch returns child layers in reverse order (back to front),
      // so we'll loop backwards through them:
      for (var sub=([sublayers count] - 1); sub >= 0; sub--) {
        var current = [sublayers objectAtIndex:sub]
        process_layer(current,layer_data.children,depth+1);
      }
    }
    export_layer(layer, depth);
    metadata_container.push(layer_data);

    if ([layer name].indexOf("@@hidden") != -1) {
      // If it was hidden, make it hidden again and fix the name
      var _name = [layer name].replace("@@hidden", "");
      [layer setIsVisible:false];
      [layer setName:_name];
    }
  }

  if ([layer name].indexOf("@@mask") != -1) {
    var _name = [layer name].replace("@@mask", "");
    log("Re-enabling mask " + _name);
    [layer setHasClippingMask:true];
    [layer setName:_name];
  }
}
function save_file_from_string(filename,the_string) {
  var path = [@"" stringByAppendingString:filename],
      str = [@"" stringByAppendingString:the_string];

  if (in_sandbox()) {
    sandboxAccess.accessFilePath_withBlock_persistPermission(filename, function(){
      [str writeToFile:path atomically:true encoding:NSUTF8StringEncoding error:null];
    }, true)
  } else {
    [str writeToFile:path atomically:true encoding:NSUTF8StringEncoding error:null];
  }
}
function get_next_id() {
  return ++object_id;
}
function mask_bounds(layer) {
  var sublayers = [layer layers];
  var effective_mask = null;

  for (var sub=0; sub < [sublayers count]; sub++) {
    var current = [sublayers objectAtIndex:sub];
    if(current && [current hasClippingMask]) {
      // If a native mask is detected, rename it and disable it (for now) so we can export its contents
      var _name = [current name] + "@@mask";
      [current setName:_name];
      [current setHasClippingMask:false];
      log("Disabling mask " + [current name]);

      if (!effective_mask) {
        // Only the bottom-most one will be effective
        log("Effective mask " + _name)
        effective_mask = current
      }
    }
  }

  if (effective_mask) {
    return metadata_for(effective_mask);
  } else {
    return null;
  }
}
function calculate_real_position_for(layer) {

  var gkrect = [GKRect rectWithRect:[layer rectByAccountingForStyleSize:[[layer absoluteRect] rect]]],
      absrect = [layer absoluteRect];

  var rulerDeltaX = [absrect rulerX] - [absrect x],
      rulerDeltaY = [absrect rulerY] - [absrect y],
      GKRectRulerX = [gkrect x] + rulerDeltaX,
      GKRectRulerY = [gkrect y] + rulerDeltaY;

  return {
    x: Math.round(GKRectRulerX),
    y: Math.round(GKRectRulerY)
  }
}
function metadata_for(layer) {
  var frame = [layer frame],
      gkrect = [GKRect rectWithRect:[layer rectByAccountingForStyleSize:[[layer absoluteRect] rect]]],
      absrect = [layer absoluteRect],
      position = calculate_real_position_for(layer),
      x,y,w,h,r

      if ([layer className] == "MSArtboardGroup") {
        // FIXME: This is probably still wrong, test with different artboard positions
        x = [[layer absoluteRect] rulerX],
        y = [[layer absoluteRect] rulerY],
        // x = position.x,
        // y = position.y,
        w = [frame width],
        h = [frame height],
        r = {
          x: x,
          y: y,
          width: w,
          height: h
        }
      } else {
        x = position.x,
        y = position.y,
        w = [gkrect width],
        h = [gkrect height],
        r = {
          x: x,
          y: y,
          width: w,
          height: h
        }
      }

  log("{ x:"+x+", y:"+y+", width:"+w+", height:"+h+"}")

  return r
}
function extract_metadata_from(layer) {
  var maskFrame = mask_bounds(layer);
  var layerFrame = metadata_for(layer);
  // call maskframe first so it disables the mask, so we can get correct layerframe

  //metadata.id = get_next_id(); // FIXME

  var metadata = {
    name: sanitize_filename([layer name]),
    layerFrame: layerFrame,
    maskFrame: maskFrame
  };

  if(has_art(layer)) {
    metadata.image = {
      path: "images/" + sanitize_filename([layer name]) + ".png",
      frame: layerFrame
    };
    metadata.imageType = "png";
    // TODO: Find out how the modification hash is calculated in Framer.app
    // metadata.modification = new Date();
  }

  // if it was invisible, mark this in the metadata as well
  if ([layer name].indexOf("@@hidden") != -1) {
    metadata.visible = false
  }

  return metadata;
}

function extract_shadow_from(layer) {
  //TODO: Get the blur properties
  var styles = {}
  var styleObjects = layer.style().shadows().array()
  log('Checking shadow'+' '+[styleObjects count]+' '+styles+' '+styleObjects)

  var CSSShadow=false;
  
  for(var i=0;i<[styleObjects count];i++){
    var shadowObject =[styleObjects objectAtIndex:i]
    log('Found shadow'+shadowObject)
    
    var shadowColor='rgba('
      +Math.round(shadowObject.color().red()*255)+','
      +Math.round(shadowObject.color().green()*255)+','
      +Math.round(shadowObject.color().blue()*255)+','
      +shadowObject.color().alpha()+')'
    CSSShadow = shadowObject.offsetX()+'px '+shadowObject.offsetY()+'px '+shadowObject.blurRadius()+'px '+shadowObject.spread()+'px '+shadowColor;
    
    //layer.style().shadows().removeStylePart(shadowObject)
  }
  return CSSShadow;

}

function extract_style_from(shapeLayer) {
  /*
  var styles = {}
  var borders = shapeLayer.style().borders().array()

  log('CSS Box:  '+ shapeLayer.CSSAttributeString().toString()+' ')
  for(var borderIndex = 0; borderIndex < borders.length; borderIndex++){
    var border = borders[borderIndex]
    log('CSS Box border is  '+ border)
    styles.borderSize = border.thickness();
    styles.borderColor = 'rgba('
      +Math.round(border.color().red()*255)+','
      +Math.round(border.color().green()*255)+','
      +Math.round(border.color().blue()*255)+','
      +border.color().alpha()+')'
    
    log('CSS Box border position:  '+ border.position())
    log('CSS Box border fillType:  '+ border.fillType())
    log('CSS Box border gradient:  '+ border.gradient())
    log('CSS Box border isEnabled:  '+ border.isEnabled())
    log('CSS Box border red:  '+ border.color().red())
    log('CSS Box border blue:  '+ border.color().blue())
    log('CSS Box border green:  '+ border.color().green())
    log('CSS Box border alpha:  '+ border.color().alpha())
    
  }

  var fills = shapeLayer.style().fills().array()
  log('CSS Box has fills  '+ fills.length)
  for(var fillIndex = 0; fillIndex < fills.length; fillIndex++){
    var fill = fills[fillIndex]
    styles.backgroundColor = 'rgba('
      +Math.round(fill.color().red()*255)+','
      +Math.round(fill.color().green()*255)+','
      +Math.round(fill.color().blue()*255)+','
      +fill.color().alpha()+')'
    log('CSS Box fill is  '+ fill)
    log('CSS Box fill fillType:  '+ fill.fillType())
    log('CSS Box fill red:  '+ fill.color().red())
    log('CSS Box fill blue:  '+ fill.color().blue())
    log('CSS Box fill green:  '+ fill.color().green())
    log('CSS Box fill alpha:  '+ fill.color().alpha())
    log('CSS Box fill gradient:  '+ fill.gradient())
    log('CSS Box fill isEnabled:  '+ fill.isEnabled())
  }
  */

  var CSSString = shapeLayer.CSSAttributeString().toString();
  var styles ={}

  var stylestemp = CSSString.split('\n');
  
  for (var i = 0; i < stylestemp.length ; i++) {
    var values = stylestemp[i].split(':');
    if(values.length>1 && stylestemp[i].indexOf('//')==-1 && stylestemp[i].indexOf('/*')==-1){
      var attr = values[0].replace( /-(\w)/g, function _replace( $1, $2 ) {return $2.toUpperCase();});
      var val = values[1].replace(';','')
      log('style values'+attr+':'+values[1].replace(';',''));
      styles[attr] = val;
    }
  } 
  
  return styles
  //+'\n-webkit-transform: rotateZ('+shapeLayer.rotation()+'deg);'

}
function lookForCSSBoxBackground(layer){
  var layerChildren = [layer children]
  var CSSBoxBackground = false;

  if([layerChildren count] > 0){
    for (var layerIndex =0;layerIndex < [layerChildren count]; layerIndex++){
      var child = [layerChildren objectAtIndex:layerIndex]
      if(child.class() == 'MSShapeGroup' && layerIndex < 3 && child.isPartOfClippingMask()){
        CSSBoxBackground = child
      }else if(child.class() == 'MSShapeGroup' && layerIndex < 2 && !child.hasClippingMask()){
        CSSBoxBackground = child
      }
    }
  }
  return CSSBoxBackground;
}


function findAssetsPage(focusPage, firstArtboard){
  var assetsPage = false
  var allPages = [doc pages];
  for(var p=0; p < [allPages count]; p++){
    var currentPage = [allPages objectAtIndex:p]
    if(currentPage.name() == 'FramerComponents'){
      assetsPage = currentPage;
    }
  }
  return assetsPage;
}
function updateAssetsPage(focusPage, firstArtboard){
  var assetsPage = findAssetsPage(focusPage, firstArtboard)
  if(assetsPage!=false){
    doc.removePage(assetsPage)
  }

  assetsPage = [doc addBlankPage]
  assetsPage.setName("FramerComponents")

  var copyOfArtboard = [firstArtboard copy]

  assetsPage.addLayer(copyOfArtboard)
  var copyOfArtboardLayers = [copyOfArtboard layers]

  for(var l=0; l < [copyOfArtboardLayers count]; l++){
    addLayerToAssetsPage([copyOfArtboardLayers objectAtIndex:l],assetsPage)
  }

  [copyOfArtboard removeFromParent]

  return assetsPage;
  
}
function addLayerToAssetsPage(layer,assetsPage){
  if (is_group(layer) && should_become_view(layer)) {
    var styles = {}
    assetsPage.addLayer(layer)

    layer.style().contextSettings().opacity = 1

    var rect = [GKRect rectWithRect:[layer rectByAccountingForStyleSize:[[layer absoluteRect] rect]]]
    var layerFrameHeightWithStyle = [rect height]
    var orginalRect = [GKRect rectWithRect:[[layer absoluteRect] rect]]
    var layerFrameHeight = [orginalRect height]

    log('height with style '+layerFrameHeightWithStyle)
    
    var label = assetsPage.addLayerOfType("text");
    var layerName = (layer.name()) ? layer.name() : 'Undefined layer';
    label.setName("label for "+layerName);
    label.fontSize = 11;
    label.fontPostscriptName = "Lucida Grande"
    var fontColor = [[MSColor alloc] init];
    [fontColor setRed:0.45];
    [fontColor setGreen:0.45];
    [fontColor setBlue:0.45];
    [fontColor setAlpha:1];

    label.textColor = fontColor

    label.setStringValue(layerName)
    labelFrame = label.frame()
    labelFrame.y = AssetsOffset + 30

    layerFrame = layer.frame()
    layerFrame.x = 0
    layerFrame.y = AssetsOffset + 48 + (layerFrameHeightWithStyle-layerFrameHeight)

    AssetsOffset += layerFrameHeightWithStyle + 56

    /* TODO: When using CSS, remove the shadows from images
    var shadowObjects = [[layer style] shadows]
    var shadowObjectsArray = [shadowObjects array]

    for(var i=0;i<[shadowObjectsArray count];i++){
      log('found shadow'+shadowObjects[i])
      var shadowObject = [shadowObjectsArray objectAtIndex:i]
      [shadowObjects removeStylePart:shadowObject]
    }
    */

    
    var sublayers = [layer layers];

    for (var sub=([sublayers count] - 1); sub >= 0; sub--) {
      var current = [sublayers objectAtIndex:sub];
      if(is_group(current) && should_become_view(current)){
        current.removeFromParent()
        addLayerToAssetsPage(current,assetsPage)
      }
      if(current.hasClippingMask()) {
        [current setHasClippingMask:false]
        var maskParent = current.parentGroup();
        var maskParentFrame = maskParent.frame();
        maskParent.resizeRoot()
        maskParentFrame.x = 0
        AssetsOffset += maskParentFrame.height() - layerFrameHeightWithStyle
        [current setHasClippingMask:true]
      }
    }

    /* TODO: Figure out how to scale up bitmaps on the Components page
    But the question is how do you tell what the native resolution of a bitmap is? writeBitmapImageToFile?
    log('should I export '+layer+' bitmap: '+is_bitmap(layer))
    if(is_bitmap(layer)){
      //export_full_bitmap(page, layer,images_folder + "/" + sanitize_filename(layer.name()) + "-bitmap.png")
    }
    */
  }
  
}

var document_path = [[doc fileURL] path].split([doc displayName])[0],
    document_name = [doc displayName].replace(".sketch",""),
    target_folder = document_path + document_name,
    images_folder = target_folder + "/images",
    file_manager = [NSFileManager defaultManager],
    object_id = 0,
    AssetsOffset = 0

function main() {

  log('#################################################################################################################################################');

  var focusPage = [doc currentPage]
  var currentArtboards = [focusPage artboards]
  var firstArtboard = [currentArtboards lastObject]
  var allPages = [doc pages];

  if([currentArtboards count] > 0){
    var assetsPage = updateAssetsPage(focusPage, firstArtboard);
    //process_all_artboards(focusPage);
    //process_all_layers(assetsPage);
    //create_files(focusPage, project_metadata, states_metadata)

    // Create folders
    if (in_sandbox()) {
      sandboxAccess.accessFilePath_withBlock_persistPermission(target_folder, function(){
        [file_manager createDirectoryAtPath:target_folder withIntermediateDirectories:true attributes:nil error:nil];
        [file_manager createDirectoryAtPath:images_folder withIntermediateDirectories:true attributes:nil error:nil];
      }, true)
    } else {
      [file_manager createDirectoryAtPath:target_folder withIntermediateDirectories:true attributes:nil error:nil];
      [file_manager createDirectoryAtPath:images_folder withIntermediateDirectories:true attributes:nil error:nil];
    }

    // Get all layers in current page
    var all_layers = [[doc currentPage] layers],
        metadata = [];

    for (var i=0; i < [all_layers count]; i++) {
      process_layer([all_layers objectAtIndex:i],metadata, 0);
    }

    [doc setCurrentPage:focusPage]
    [doc showMessage: "Sketch Framer: Project exported to “" + target_folder + "”"];
    
  }else{
    [doc showMessage: "Sketch Framer: You must have multiple artboards for this to work"];
  }

  log('#################################################################################################################################################');

  // Display message in toolbar
  [doc showMessage: "Sketch Framer: Project exported to “" + target_folder + "”"];

}

/*

This plugin will export your Sketch document to a Framer project.

This command REQUIRES at least Sketch Version 2.3 (419),
as it uses an API not available in earlier versions

- Every layer group will become an ImageView, backed by the pixel and/or shape layers in that layer group.
- Views are accessible by name under the PSD object (yeah, I know...)
- Framer respects the layer hierarchy, so a sub layer group will become a subview. This way you can define your view structure in Photoshop.
- TODO: Layer groups with vector masks will become views with clipping enabled. You can optionally add "scroll" to the layer group name to make it a ScrollView.
- Layer group names should be unique, if they're not Framer will silently rename them on export.

// TODO: Check for duplicated names in exported files
// TODO: Calculate proper IDs (not sure what they're used for, but hey...)
// TODO: Calculate proper modification hash
// TODO: Embed framer.js on this file, instead of 'curl'ing it from Github

*/

main();
